---
layout: post
title: "JAMStack, just another web stack?"
date: 2020-05-28 10:00:00
tags: [JAMStack, Modern Web Architecture, Xmartlabs]
category: development
author_id: mtnBarreto
show: true
featured_image: /images/jamstack-intro/featured.jpeg
crosspost_to_medium: false
---

JAMstack is likely a top trends in web development nowadays. Everyone is talking about the modern web development architecture. In this blogpost I'm gonna cover what caused JAMSTack rapidly adoption, the JAMStack community and ecosystem and of course what JAMStack means.

## JAMStack

You may have already seen or worked on a JAMstack site! First of all, it's worth clarifying that JAMStack has nothing to do with programming languages or technology, it's just nomenclature and a kind of definition to a already existing modern web stack and ecosystem. This new web architecture (we gonna talk about it shortly) tries to get around the poor security, performance and scalability issues of the monolithic web architecture we have been using the last 10 years.

The thing that they all have in common is that they don’t depend on a web server.

>agnostic.

>JAMStack is a new way of building websites and apps that delivers better performance, higher security, lower cost of scaling,
and a better developer experience.

**JAM**Stack stands for Javascript, APIs and Markup respectively.

**Javascript** running on the browser handles any dynamic aspect. Notice that there is no need of dedicated server. Could be any frontend framework, library or even raw javascript. Optionally it may be a SPA (single page application) but JAMstack does not define that.

**APIs** All server side actions are encapsulated into microservices, usually third party managed microservices. The Javascript code running on the browser consumes these services through http calls and typically exchanging json format data (not html).

**Markup/Markdown** Some template system engine is used to pre-build the entire static site at deploy time, usually using a SSG (static site generator) for content sites or a build tool for web apps. Also markdown is relatively easy to learn and we can easily create html content from it using a template engine.  

The main point behind JAMStack is leverage the browser and JS capabilities by prebuilding as much content as possible so we can serve these content from the CDN, by doing that we are actually decoupling the front-end from the backend (here the sevaral microservices). Instead of having a monolithic server building and serving the resources this modern web architecture splits these functionalities into small microservices which are consumed from the main app running on a browser client. This main app is served through CDNs nodes.

## Why the JAMstack?

> From JSMstack.org website

- **Better Performance:** Why wait for pages to build on the fly when you can generate them at deploy time? When it comes to minimizing the time to first byte, nothing beats pre-built files served over a CDN. Performance can impact conversion rates. No more centric origin of content.
- **Higher Security:** With server-side processes abstracted into microservice APIs, surface areas for attacks are reduced. You can also leverage the domain expertise of specialist third-party services.
- **Cheaper, Easier Scaling:** When your deployment amounts to a stack of files that can be served anywhere, scaling is a matter of serving those files in more places. CDNs are perfect for this, and often include scaling in all of their plans.
- **Better Developer Experience** Loose coupling and separation of controls allow for more targeted development and debugging, and the expanding selection of CMS options for site generators remove the need to maintain a separate stack for content and marketing.


> Faster - Rendering sites faster and save money.
> Serverless - No need for servers, devops or costly infraestructure.
> Highly composable. (payment server)
> open source.  
> JWT....

> Improved scaling: Static content can be placed on a CDN making it easier to dynamically scale.
> Heightened security: The lack of databases, plugins, and dynamic software running on a server decreases the potential for code injections and breaches. Additionally, since APIs handle dynamic functions, the web developer can leverage third parties’ security expertise.
> Accelerated load times: The JAMstack is faster because the browser processes functionality that the back-end traditionally executed. Prebuilt HTML files can be served over a CDN instead of rendering documents live on the server. Additionally, the JAMstack minimizes database queries, accelerating content delivery. During an experiment Smashing Magazine found that using a static version distributed via a CDN loaded the first byte six times faster than a dynamic website.
> Better developer experience: Loose coupling and separation of controls allow for more targeted development and debugging. The ability to leverage third party APIs means developers can focus on value-added features. Additionally, using a Git repository allows the entire website to be centrally hosted. In turn, developers can easily make changes by pushing a commit to the version-controlled repository. The JAMstack applies CI/CD to expedite development.


> Better developer experience: Loose coupling and separation of controls allow for more targeted development and debugging. The ability to leverage third party APIs means developers can focus on value-added features. Additionally, using a Git repository allows the entire website to be centrally hosted. In turn, developers can easily make changes by pushing a commit to the version-controlled repository. The JAMstack applies CI/CD to expedite development.



#### Monolithic web stack vs (JAMStack) modern web stack

Web web stack architecture and ecosystem has been evolving since it very beginning, let's compare the monolithic stack with the "modern web stack" JAMStack.

**Monolithic web stack**

The monolithic web architecture is the way we have been creating web app over the last decade and half where each document is created on the fly upon a http request (rails, express, Flask are some web frameworks which follows this approach). Here the browser communicates with a central server that communicates to a db layer. This approach has caused a lot of security issues since we create almost every document from scratch, it also suffers performance and scalability issues. Normally we end up adding many caching layers, db caching, memory caching and http caching and so on. We can say that the site needs to be build each time it's served.

> Single point of source, single point of failure.  No matter how many caching plugins you use on still serving this data from the same source.


**Modern web stack**

 In contrast to monolithic web approach, there is no single origin of content, there is no single point of failure. Also we can say that loading time from any part of the world is pretty much the same since these frontend-code is distributed all over the world through CDNs.

Decoupled architecture + Git Centric Workflow = Better Web (faster, no more malware, out of the box scalable infinetely)


## What caused JAMStack rapidly adoption

In the last years frontend development has turned out drastically.

### Git grow

Git started to be more popular not only for version control but also starting to become the way developers collaborate, communicate and publish apps. Interesting also how FTP lost adoptions as fast as git gains.

<script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/2213_RC01/embed_loader.js"></script> <script type="text/javascript"> trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"/m/05vqwg","geo":"","time":"2010-01-01 2020-06-04"},{"keyword":"/m/0dzxs","geo":"","time":"2010-01-01 2020-06-04"}],"category":0,"property":""}, {"exploreQuery":"date=2010-01-01%202020-06-04&q=%2Fm%2F05vqwg,%2Fm%2F0dzxs","guestPath":"https://trends.google.com:443/trends/embed/"}); </script>

### Browser capabilities & Front-end build tools

Also browsers become really powerful, nowadays a browser is a lot more than a document viewer, it's a document viewer with a JS application runtime. Also the front-end build tools and all kind of pre/post processors have exploded. All these tools completely changed the daily workflow of the front-end developers.

>The new front-end stack, front end build tools, API economy.
Building and compiling staff is becoming a essencial part of the modern web development workflow.


### Microservices economy

And finally, API microservices become more popular, there are specific services to anything and web developers started to rely and combine these microservices saving a lot of time. These microservices can be consumed directly from the browser or eventually from a backend.


truly composable

some of them build by ourself, some of them managed services bu other people.


<script type="text/javascript"></script> <script type="text/javascript"> trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"/m/011spz0k","geo":"","time":"2010-01-01 2020-06-04"}],"category":0,"property":""}, {"exploreQuery":"date=2010-01-01%202020-06-04&q=%2Fm%2F011spz0k","guestPath":"https://trends.google.com:443/trends/embed/"}); </script>

> API Economy emergying. All this 3th parties service tht we cn directly plug -in from the browser. Which exposes different functionalities.

## JAMStack Best Practises

**Use CFN to serve your files rather than servers** JAMStack apps should not rely on a centric origin of data or single server. JAMStack, at deploy time, pre-build the static data typically by using a SSG (static site generator) which then is served from a CDN.    

**Modern Build tools** Ideally we should take advantage of modern build tools. By using tools like Babel, PostCSS, Webpack, Gulp/Grunt we are able to use web standards still not supported in the market browsers, we can follow good practices optimizing assets and automating repetitive and time consuming tasks.

**Everything lives in git** The entire site should be pushed to git and ideally we should use git as our source and data db. CI and CD should be able to completely pre-build and  deploy de entire site whenever a git remote branch changes. By doing so our entire website will reside in one centralized location protected by robust version control system.


Adopting this new modern web stack we get a scalable app out of the box. Something important is to make the the. In order to accomplish that there was a swift on how developer works. Basically a new git centric workflow arises where developers create branch, pull request and merge these changes into production branch then a kind of continues delivery process automatically runs, pre-build the frontent content and deploy them to the CDNs. So any changes in git will automatically reflected and pushed to the CDN all over the world.

Modern build tools?
automated builds ;). Just rely on your git flow. Git centric workflow.

How can we build on to of git? how can we make more powerful the git workflow we are already using?

>Distributing the frontend all over the world. Everything lives in git. Git centric workflow. HOw can we build on top of git centric workflow? How can we expand the workflow we use as developers and make it more powerful?


**Automated builds** In order to same time we should automate site markup pre-build tasks. Before deploy we need to pre-build and doing this manually is not a good choice.

We prebuild as much as we can through build tools.


**Atomic deploys** Any CDN content update must be performed at the same time despite the a app size and the amount of files involved. No changes should go live until all changed files have been updated otherwise can cause inconsistent state while the update process completes.

**Instant cache invalidation** Cache Control values in each file must be property set up to avoid inconsistent outdated files after deploying to a CDN.


## Static Site Generators

[staticgen.com](https://www.staticgen.com) lists all SSG alternatives including the frameworks to build static site with react or vue.js.

Hugo and Eleventry seems to me the most interesting SSG.
**Hugo** because is super fast to build the site since it's entirely implemented in GO language.
**Eleventy** is easy to use and we can choose the template system language that is super handly.

[nextjs](https://nextjs.org/) and [gatsbyjs](https://www.gatsbyjs.org/) are popular static site generators for react.js.
[nuxtjs](https://nuxtjs.org/) and [gridsome](https://gridsome.org/) allows us to generate a static site using vue.js.


## Microservices economy

**Deploy to CDN**

[Netlify](https://www.netlify.com/) A publishing platform for the modern web. It offers CI & CD and app distribution to CDNs services.  

**Serverless compute services**

[AWS Lambda](https://aws.amazon.com/lambda/)  
[Google serverless computing solutions](https://cloud.google.com/serverless-options)  
[Microsoft serverless computing solutions](https://azure.microsoft.com/en-us/overview/serverless-computing/)  

**Headless CMS**

There are many microservices providing content management system solutions, each one with its pros and cons. Elaborating more about them and a complete comparison could be a entire blogpost and it's not the point of this blogpost.

[sanity.io](https://www.sanity.io/)  
[storyblok](https://www.storyblok.com/)  
[prismic.io](https://prismic.io/)  
[contentful](https://www.contentful.com/)  
[ghost](https://ghost.org/)  
[netlifycms](https://www.netlifycms.org/)

**DB**

[faunaDB](https://fauna.com/)  
[firebase](https://firebase.com/)  
[Amazon DynamoDB](https://aws.amazon.com/dynamodb/)  
[Azure Cosmos DB](https://azure.microsoft.com/en-us/services/cosmos-db/)  

[Amazon Aurora Serverless](https://aws.amazon.com/rds/aurora/serverless/)  
[Amazon Relational Database Service](https://aws.amazon.com/rds/)  
[Cloud SQL](https://cloud.google.com/sql/docs/)  





----------------------------------------------------------------------------------------------------------------------------








## When is your site not built with the Jamstack?

Any project that relies on a tight coupling between client and server is not built with the Jamstack. This would include:

- A site built with a server-side CMS like WordPress, Drupal, Joomla, or Squarespace.
- A single page app that uses isomorphic rendering to build views on the server at runtime.
- A monolithic server-run web app that relies on Ruby, Node, or another backend language.







---------------------

According [jamstack.org](https://jamstack.org/)

> Fast and secure sites and apps delivered by pre-rendering files and serving them directly from a CDN,
removing the requirement to manage or run web servers.

When we talk about “The Stack”, we no longer talk about operating systems, specific web servers, backend programming languages, or databases.

The Jamstack is not about specific technologies. It’s a new way of building websites and apps that delivers better performance, higher security, lower cost of scaling, and a better developer experience.

Pre-rendered sites can be enhanced with JavaScript and the growing capabilities of browsers and services available via APIs.



### What is the Jamstack?



Mathias Biilmann, the CEO of Netlify, describes JAMstack as
> a modern web development architecture based on client-side JavaScript, reusable APIs, and prebuilt Markup.”



 The JAMstack stands for JavaScript, APIs, and Markup:

- **JavaScript (J):** JavaScript running entirely on the client handles any dynamic programming during the request/response
cycle (e.g. Vue.js, React.js).
- **APIs (A):** Reusable APIs accessed over HTTP with JavaScript abstract all server-side processes or database actions (e.g. Twilio, Stripe).
- **Markup (M):** Templated markup should be prebuilt at deploy time, usually using a site generator for content sites,
or a build tool for web apps (e.g. Gatsby.js, Webpack).




The JAMstack offers an alternative to the LAMP and MEAN stacks and has some advantages like scaling, security, speed, and developer experience. Service Workers and serverless functionality enrich the JAMstack. Modern front-end development reflects the broader trend of componentization, and we categorize +110 solutions in the space. As the market matures we expect to see an increasing number of commercial offerings.

Powerful mobile computing, modern browsers, Static Site Generators (SSG), expansive Content Delivery Networks (CDNs), and the API economy catalyzed the JAMstack’s emergence. The JAMstack stands for JavaScript, APIs, and Markup. Jamstack.org defines each component as the following:
JavaScript (J): JavaScript running entirely on the client handles any dynamic programming during the request/response cycle (e.g. Vue.js, React.js).
APIs (A): Reusable APIs accessed over HTTP with JavaScript abstract all server-side processes or database actions (e.g. Twilio, Stripe).
Markup (M): Templated markup should be prebuilt at deploy time, usually using a site generator for content sites, or a build tool for web apps (e.g. Gatsby.js, Webpack).





> Netlify officially released Functions, a tool to facilitate deploying AWS Lambda functions by only requiring a developer to add a file to their Git repository. Netlify automatically recognizes the function and deploys it, minimizing the developer’s need to ramp up on AWS Lambda.






## Modern front-end development

Modern front-end development with APIs and functions reflects a broader trend, componentization. Similar to how developers are breaking down the monolith and building microservices leveraging APIs, the front-end is going through the same decomposition. To assemble the front-end, developers draw from third-party APIs and internally-built individual components that express specific functionality of the page. Developers need to develop, visualize, and manage the different pieces, increasing the complexity of their work.


The front-end ecosystem is rapidly evolving, and we identify ~110 modern solutions in the space. We appreciate that solutions may have offerings across different areas, but we attempt to place them in a core category. The vast majority are open source, especially in the JavaScript, Static Site Generator (SSG), and build categories. There are also venture-backed startups like Netlify in CDN/hosting and Contentful in headless CMS.
jamstackecosystem


## Best Practices

When building Jamstack projects, you can really get the most out of the stack if you stick to a few best practices.

- **Whole project on a CDN:** Because Jamstack projects don’t rely on server-side code, they can be distributed instead of
living on a single server. Serving directly from a CDN unlocks speeds and performance that can’t be beat.
The more of your app you can push to the edge, the better the user experience.
- **Everything Lives in Git. No server needs:** With a Jamstack project, anyone should be able to do a git clone, install any
needed dependencies with a standard procedure (like npm install), and be ready to run the full project locally.
No databases to clone, no complex installs. This reduces contributor friction, and also simplifies staging and testing workflows.
- **Modern Build Tools:** Take advantage of the world of modern build tools. It can be a jungle to get oriented in and it’s a fast moving space, but you’ll want to be able to use tomorrow’s web standards today without waiting for tomorrow’s browsers. And that currently means Babel, PostCSS, Webpack, and friends.
- **Automated Builds, Atomic Deploys, Instant Cache Invalidation**







The JAMstack offers an alternative to the LAMP and MEAN stacks and has some advantages like scaling, security, speed, and developer experience. Service Workers and serverless functionality enrich the JAMstack. Modern front-end development reflects the broader trend of componentization, and we categorize +110 solutions in the space. As the market matures we expect to see an increasing number of commercial offerings.
Powerful mobile computing, modern browsers, Static Site Generators (SSG), expansive Content Delivery Networks (CDNs), and the API economy catalyzed the JAMstack’s emergence.

Git, a central source code repository, is fundamental to the JAMstack because it holds all the site’s components. A SSG generates the browser markup, which is pushed to Git as a collection of prebuilt pages. The CDN and/or hosting service can identify the changes, automatically rebuild the site, and deploy it. This workflow embodies the modern software development life cycle practice of Continuous Integration and Deployment (CI/CD).

The JAMstack is an alternative to the LAMP and MEAN stacks. In the early 2000s, the LAMP stack originated from four open-source components that developers adopted to build a site: the Linux operating system, the Apache HTTP Server, the MySQL RDBMS, and the PHP language. In 2013 MongoDB introduced the MEAN stack that included MongoDB, Express.js, Angular.js, and node.js. The MEAN stack improved upon the LAMP stack because it supported a modern NoSQL database, more responsive user interface (UI), and one language, JavaScript, for communication between front-end and back-end functions. Similar to the LAMP stack, the MEAN stack distinguished between the view and model layer.

> static sites refer to how sites are built and served, not the level of interactivity.


Traditionally, every time a user requests a page, a server queries a database and combines the result with data from the page’s markup and plugins to generate a new HTML document in the browser. This process can slow page load times. With the ability to abstract back-end functionality and leverage powerful front-end technology, the JAMstack represents a modern workflow. When a user requests a page, there is no need to query the database as the HTML document is a cached static file that is sent to the browser.
