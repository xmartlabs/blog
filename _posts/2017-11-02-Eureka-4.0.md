---
layout: post
title:  EUREKA 4.0 is now available!
date:   2017-11-02 09:30:00
author: XL Team
author_id: xl
categories: Swift, iOS, Eureka
markdown: redcarpet

---

If you are not familiar with Eureka, it is a framework used to build forms in iOS.
To learn more about it you can start by reading
[Introducing Eureka iOS form library written in pure Swift](https://blog.xmartlabs.com/2015/09/29/Introducing-Eureka-iOS-form-library-written-in-pure-Swift/) or visit [Eureka's GitHub page](https://github.com/xmartlabs/Eureka) where you can find all the latest changes.

We are very happy to announce that version 4.0 of Eureka is now available, which includes support to Swift 4. Also we want to remind you that the version 3.0 includes some bug fixes like memory leaks and new features that some of you desire a lot.

The version 4.0 doesn't includes new features, but we will discover some new features that version 3.0 includes:
 - Multivalued section
 - Usage of nib file for all rows

## Multivalued section
How many times have you desired to create a section where the user will be able to insert, move or delete rows?
Like a contacts library or a calendar events with different priorities or anything that you can imagine!

The idea of this feature is to allow us to easily create sections with insertable, deletable and re-orderable rows.

<p align='center'>
  <img src='https://raw.githubusercontent.com/xmartlabs/Eureka/master/Example/Media/EurekaMultivalued.gif' alt='Ahoy in action!'/>
</p>


#### How to use it?
In order to create a multivalued section we have to use MultivaluedSection type instead of the regular Section type. `MultivaluedSection` extends `Section` and has some additional properties to configure multivalued section behavior.

```swift
form +++
    MultivaluedSection(multivaluedOptions: [.Reorder, .Insert, .Delete],
                       header: "Multivalued TextField",
                       footer: ".Insert adds a 'Add Item' (Add New Tag) button row as last cell.") {
        $0.addButtonProvider = { section in
            return ButtonRow(){
                $0.title = "Add New Tag"
            }
        }
        $0.multivaluedRowToInsertAt = { index in
            return NameRow() {
                $0.placeholder = "Tag Name"
            }
        }
        $0 <<< NameRow() {
            $0.placeholder = "Tag Name"
        }
    }
```

The previous code snippet shows how to create a multivalued section. In this case we want to insert, delete and reorder rows as the `multivaluedOptions` argument indicates.

You can find an usage example in the [Eureka project](https://github.com/xmartlabs/Eureka).


## Usage of nib file in all the rows
Before this version if we want to changed the layout of a cell we had to create a custom row and it had to be as a subclass of an existent row, without taking in count that the changed maybe was so little.

The other chance, if the modification was about fonts and colors, we could use the methods **defaultCellUpdate** and **defaultCellSetup** on the type of the row and that allowed us to set the colors, fonts, aligns, etc.

But what happened when the changes were bigger? When the changes were in the layout (like constraints), we had to create a custom row.

But now, it is possible to modify the layout of a row without creating a custom row. We decided to make some changes to allow the usage of a nib file to create your own row style and the way that it is showed.
This is a big change for all the users of Eureka!!

Of course that sometimes it is not enough to modify an existing row, because there are a lot of changes to make on it, so in that case that we need to create a custom row. If is this your case, you can see some custom rows that already exist [EurekaCommunity]( https://github.com/EurekaCommunity).

#### How to use it?
In some few steps you can modify layout constraints or add some custom UI components that you need in an existent row. For example... imagine that you want to use an Eureka row, but you want to have some extra components. All you need to do is follow this steps:
 - Create a nib file
 - Add all the UI components that you need
 - Connect the outlets to your cell class
 - Convert you cell class as a subclass of NameRow for example.

 Everything is done! You have a row with all that Eureka can gives you and all the extra components that you desire, without having to create a new custom row.


## Where to go from here
We hope that this features make the usage of this library more enjoyable and more productive!
And as always; if you liked what you have read, want to suggest some feature, contribute to the project or you need some help, feel free to contact us or contribute with this [library](https://github.com/xmartlabs/Eureka).
